<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Go Pizza Linux Studio - Gerador ISO9660 básico</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #eee;
    padding: 20px;
  }
  h1 { color: #FF6F00; }
  textarea {
    width: 100%;
    height: 130px;
    background: #222;
    color: #eee;
    border: none;
    padding: 10px;
    font-family: monospace;
    font-size: 14px;
    margin-bottom: 15px;
    resize: vertical;
  }
  label { font-weight: bold; margin-top: 15px; display: block; }
  input[type="text"] {
    width: 300px;
    padding: 8px;
    font-size: 14px;
    margin-bottom: 20px;
  }
  button {
    background: #FF6F00;
    color: #fff;
    border: none;
    padding: 12px 25px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 5px;
  }
  button:hover { background: #e65c00; }
  .container { max-width: 900px; margin: auto; }
  #log {
    margin-top: 15px;
    background: #222;
    padding: 10px;
    height: 120px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 13px;
    border-radius: 5px;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Go Pizza Linux Studio - Gerador ISO9660 básico</h1>

    <label for="filename">Nome do arquivo ISO (ex: gopizza.iso):</label>
    <input type="text" id="filename" placeholder="gopizza.iso" value="gopizza.iso" />

    <label for="kernel">kernel.c</label>
    <textarea id="kernel" placeholder="Código do kernel.c"></textarea>

    <label for="boot">boot.asm</label>
    <textarea id="boot" placeholder="Código do boot.asm"></textarea>

    <label for="linker">linker.ld</label>
    <textarea id="linker" placeholder="Código do linker.ld"></textarea>

    <label for="makefile">Makefile (opcional)</label>
    <textarea id="makefile" placeholder="Conteúdo do Makefile (opcional)"></textarea>

    <button id="generateBtn">Gerar ISO</button>

    <div id="log"></div>
  </div>

<script>
  const SECTOR_SIZE = 2048;

  function log(msg) {
    const logDiv = document.getElementById('log');
    logDiv.textContent += msg + "\n";
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  function padRight(str, length, padChar = ' ') {
    if(str.length >= length) return str.slice(0, length);
    return str + padChar.repeat(length - str.length);
  }

  function toBothEndian32(val) {
    const buf = new ArrayBuffer(8);
    const dv = new DataView(buf);
    dv.setUint32(0, val, true);
    dv.setUint32(4, val, false);
    return new Uint8Array(buf);
  }

  function toBothEndian16(val) {
    const buf = new ArrayBuffer(4);
    const dv = new DataView(buf);
    dv.setUint16(0, val, true);
    dv.setUint16(2, val, false);
    return new Uint8Array(buf);
  }

  function createDirectoryRecord(name, extentLocation, dataLength) {
    /*
      Directory Record format ISO9660
      Length (1 byte)
      Extended Attribute Length (1 byte) = 0
      Location of extent (LSB and MSB) (8 bytes)
      Data length (LSB and MSB) (8 bytes)
      Recording Date and Time (7 bytes) - zero fill for simplicity
      File Flags (1 byte)
      File Unit Size (1 byte) = 0
      Interleave Gap Size (1 byte) = 0
      Volume Sequence Number (LSB and MSB) (4 bytes)
      Length of File Identifier (1 byte)
      File Identifier (variable)
    */

    const nameUpper = name.toUpperCase();
    const identifierLength = nameUpper.length;

    let recordLength = 33 + identifierLength;
    if(identifierLength % 2 === 0) recordLength += 1; // padding byte if name length even

    const record = new Uint8Array(recordLength);
    record[0] = recordLength;
    record[1] = 0; // extended attr length

    // extent location (logical block number)
    record.set(toBothEndian32(extentLocation), 2);

    // data length
    record.set(toBothEndian32(dataLength), 10);

    // Recording Date and Time (7 bytes) zero fill
    for(let i=18; i<25; i++) record[i] = 0;

    record[25] = 0; // File flags - 0 normal file
    record[26] = 0; // File unit size
    record[27] = 0; // Interleave gap size

    record.set(toBothEndian16(1), 28); // Volume sequence number

    record[32] = identifierLength; // length of file identifier

    for(let i=0; i<identifierLength; i++) {
      record[33+i] = nameUpper.charCodeAt(i);
    }

    // Padding byte if needed
    if(identifierLength % 2 === 0) {
      record[33 + identifierLength] = 0;
    }

    return record;
  }

  function textEncoderUTF8(text) {
    return new TextEncoder().encode(text);
  }

  function zeroPad(buffer, size) {
    const padded = new Uint8Array(size);
    padded.set(buffer);
    return padded;
  }

  function generateISO(files, volumeName) {
    log('Iniciando geração da ISO...');

    // Tamanho ISO = sistema de arquivos muito básico + dados
    // Reservaremos 50 setores para estrutura (suficiente para exemplo)
    // + dados em setores alinhados de 2048 bytes

    const systemSectors = 50;
    let dataSectorsCount = 0;
    const fileDataBuffers = [];

    for (const file of files) {
      const data = textEncoderUTF8(file.content);
      const padded = zeroPad(data, Math.ceil(data.length / SECTOR_SIZE) * SECTOR_SIZE);
      fileDataBuffers.push(padded);
      dataSectorsCount += padded.length / SECTOR_SIZE;
    }

    const totalSectors = systemSectors + dataSectorsCount;

    const isoSize = totalSectors * SECTOR_SIZE;
    const isoBuffer = new Uint8Array(isoSize);
    log(`Total setores ISO: ${totalSectors} | Tamanho: ${isoSize} bytes`);

    // 1) Preencher setor 16 com Volume Descriptor Primary
    const sector16 = 16 * SECTOR_SIZE;
    isoBuffer[sector16] = 1; // volume descriptor type primary
    const id = "CD001";
    for(let i=0; i<id.length; i++) {
      isoBuffer[sector16 + 1 + i] = id.charCodeAt(i);
    }
    isoBuffer[sector16 + 6] = 1; // version

    // System Identifier (32 bytes)
    const sysId = padRight("GO PIZZA LINUX STUDIO", 32);
    for(let i=0; i<32; i++) {
      isoBuffer[sector16 + 8 + i] = sysId.charCodeAt(i);
    }

    // Volume Identifier (32 bytes)
    const volId = padRight(volumeName, 32);
    for(let i=0; i<32; i++) {
      isoBuffer[sector16 + 40 + i] = volId.charCodeAt(i);
    }

    // Volume Space Size (4 bytes LSB + 4 bytes MSB at offset 80)
    const volSpaceSize = totalSectors;
    let offset = sector16 + 80;
    const dv = new DataView(isoBuffer.buffer);
    dv.setUint32(offset, volSpaceSize, true);
    dv.setUint32(offset+4, volSpaceSize, false);

    // Volume Set Size (2 bytes LSB + 2 bytes MSB at offset 120)
    dv.setUint16(sector16 + 120, 1, true);
    dv.setUint16(sector16 + 122, 1, false);

    // Volume Sequence Number (2 bytes LSB + 2 bytes MSB at offset 124)
    dv.setUint16(sector16 + 124, 1, true);
    dv.setUint16(sector16 + 126, 1, false);

    // Logical Block Size (2 bytes LSB + 2 bytes MSB at offset 128)
    dv.setUint16(sector16 + 128, SECTOR_SIZE, true);
    dv.setUint16(sector16 + 130, SECTOR_SIZE, false);

    // Path Table Size (4 bytes LSB + 4 bytes MSB at offset 132)
    const pathTableSize = 10;
    dv.setUint32(sector16 + 132, pathTableSize, true);
    dv.setUint32(sector16 + 136, pathTableSize, false);

    // Location of Type L Path Table (4 bytes LSB at offset 140)
    const pathTableSector = 18;
    dv.setUint32(sector16 + 140, pathTableSector, true);

    // Location of Optional Type L Path Table (4 bytes LSB at offset 144)
    dv.setUint32(sector16 + 144, 0, true);

    // Location of Type M Path Table (4 bytes MSB at offset 148)
    dv.setUint32(sector16 + 148, pathTableSector + 1, false);

    // Location of Optional Type M Path Table (4 bytes MSB at offset 152)
    dv.setUint32(sector16 + 152, 0, false);

    // Directory Record for Root Directory (34 bytes at offset 156)
    const rootDirSector = 20;
    const rootDirSize = SECTOR_SIZE;
    const rootDirRecord = createDirectoryRecord("\x00", rootDirSector, rootDirSize);
    isoBuffer.set(rootDirRecord, sector16 + 156);

    // Volume Set Identifier (128 bytes at offset 190)
    const volSetId = padRight(volumeName, 128);
    for(let i=0; i<128; i++) {
      isoBuffer[sector16 + 190 + i] = volSetId.charCodeAt(i);
    }

    // 2) Criar Path Table simples (1 entrada)
    const pathTableSectorOffset = pathTableSector * SECTOR_SIZE;
    isoBuffer[pathTableSectorOffset] = 1; // Directory Identifier Length (Root dir)
    isoBuffer[pathTableSectorOffset + 1] = 0; // Extended Attribute Record Length
    dv.setUint32(pathTableSectorOffset + 2, rootDirSector, true); // Location of Extent
    isoBuffer[pathTableSectorOffset + 6] = 1; // Parent Directory Number
    isoBuffer[pathTableSectorOffset + 7] = 0;

    // 3) Criar diretório raiz (sector 20)
    const rootDirOffset = rootDirSector * SECTOR_SIZE;
    let dirPos = rootDirOffset;

    // "." Directory record
    const dotRecord = createDirectoryRecord("\x00", rootDirSector, rootDirSize);
    isoBuffer.set(dotRecord, dirPos);
    dirPos += dotRecord.length;

    // ".." Directory record (também root)
    const dotDotRecord = createDirectoryRecord("\x01", rootDirSector, rootDirSize);
    isoBuffer.set(dotDotRecord, dirPos);
    dirPos += dotDotRecord.length;

    // Entradas para arquivos
    let currentExtentSector = rootDirSector + 1;
    for(const file of files) {
      const record = createDirectoryRecord(file.name, currentExtentSector, fileDataBuffers.shift().length);
      isoBuffer.set(record, dirPos);
      dirPos += record.length;

      // Copiar conteúdo do arquivo para setor alocado
      const dataBuffer = textEncoderUTF8(file.content);
      const dataPadded = zeroPad(dataBuffer, Math.ceil(dataBuffer.length / SECTOR_SIZE) * SECTOR_SIZE);
      const dataStart = currentExtentSector * SECTOR_SIZE;
      isoBuffer.set(dataPadded, dataStart);

      currentExtentSector += dataPadded.length / SECTOR_SIZE;
    }

    return isoBuffer;
  }

  document.getElementById('generateBtn').onclick = () => {
    const filename = document.getElementById('filename').value.trim() || 'gopizza.iso';
    if(!filename.endsWith('.iso') && !filename.endsWith('.img')) {
      alert('O arquivo deve terminar com .iso ou .img');
      return;
    }

    const kernel = document.getElementById('kernel').value;
    const boot = document.getElementById('boot').value;
    const linker = document.getElementById('linker').value;
    const makefile = document.getElementById('makefile').value;

    const files = [
      {name: 'KERNEL.C', content: kernel || '// kernel.c vazio'},
      {name: 'BOOT.ASM', content: boot || '; boot.asm vazio'},
      {name: 'LINKER.LD', content: linker || '/* linker.ld vazio */'},
    ];

    if(makefile.trim() !== '') {
      files.push({name: 'MAKEFILE', content: makefile});
    }

    log('Arquivos preparados para ISO: ' + files.map(f => f.name).join(', '));

    const isoData = generateISO(files, 'GO PIZZA LINUX STUDIO');

    log('ISO gerada, iniciando download...');

    const blob = new Blob([isoData], {type: 'application/octet-stream'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    log('Download iniciado: ' + filename);
  };
</script>
</body>
</html>
